use crate::ownership::{FileGenerator, TeamOwnership};
use fast_glob::glob_match;
use std::{
    error::Error,
    fs,
    io::Error as IoError,
    path::{Path, PathBuf},
};

pub fn team_name_from_file_path(file_path: &Path, codeowners_file_path: &PathBuf) -> Result<Option<String>, Box<dyn Error>> {
    let file_path_str = file_path
        .to_str()
        .ok_or(IoError::new(std::io::ErrorKind::InvalidInput, "Invalid file path"))?;
    let slash_prefixed = if file_path_str.starts_with("/") {
        file_path_str.to_string()
    } else {
        format!("/{}", file_path_str)
    };

    let codeowners_lines_in_priorty = build_codeowners_lines_in_priority(codeowners_file_path)?;

    for line in codeowners_lines_in_priorty {
        let (glob, team_name) = line
            .split_once(' ')
            .ok_or(IoError::new(std::io::ErrorKind::InvalidInput, "Invalid line"))?;
        if glob_match(glob, &slash_prefixed) {
            return Ok(Some(team_name.to_string()));
        }
    }

    Ok(None)
}

fn build_codeowners_lines_in_priority(codeowners_file_path: &PathBuf) -> Result<Vec<String>, Box<dyn Error>> {
    let codeowners_file = fs::read_to_string(codeowners_file_path)?;
    let stripped_lines = stripped_lines_by_priority(&codeowners_file);
    Ok(stripped_lines)
}

fn stripped_lines_by_priority(codeowners_file: &str) -> Vec<String> {
    codeowners_file
        .lines()
        .filter(|line| !line.trim().is_empty() && !line.trim().starts_with("#"))
        .map(|line| line.trim().to_string())
        .rev()
        .collect()
}

pub fn parse_for_team(team_name: String, codeowners_file: &str) -> Result<Vec<TeamOwnership>, Box<dyn Error>> {
    let mut output = vec![];
    let mut current_section: Option<TeamOwnership> = None;
    let input: String = codeowners_file.replace(&FileGenerator::disclaimer().join("\n"), "");
    let error_message = "CODEOWNERS out of date. Run `codeowners generate` to update the CODEOWNERS file";

    for line in input.trim_start().lines() {
        match line {
            comment if comment.starts_with("#") => {
                if let Some(section) = current_section.take() {
                    output.push(section);
                }
                current_section = Some(TeamOwnership::new(comment.to_string()));
            }
            "" => {
                if let Some(section) = current_section.take() {
                    output.push(section);
                }
            }
            team_line if team_line.ends_with(&team_name) => {
                let section = current_section.as_mut().ok_or(error_message)?;

                let glob = line.split_once(' ').ok_or(error_message)?.0.to_string();
                section.globs.push(glob);
            }
            _ => {}
        }
    }

    if let Some(cs) = current_section {
        output.push(cs.clone());
    }

    Ok(output)
}

#[cfg(test)]
mod tests {
    use crate::common_test::tests::vecs_match;

    use super::*;
    use indoc::indoc;

    #[test]
    fn test_parse_for_team_trims_header() -> Result<(), Box<dyn Error>> {
        let codeownership_file = indoc! {"
            # STOP! - DO NOT EDIT THIS FILE MANUALLY
            # This file was automatically generated by \"bin/codeownership validate\".
            #
            # CODEOWNERS is used for GitHub to suggest code/file owners to various GitHub
            # teams. This is useful when developers create Pull Requests since the
            # code/file owner is notified. Reference GitHub docs for more details:
            # https://help.github.com/en/articles/about-code-owners


        "};

        let team_ownership = parse_for_team("@Bar".to_string(), codeownership_file)?;
        assert!(team_ownership.is_empty());
        Ok(())
    }

    #[test]
    fn test_parse_for_team_includes_owned_globs() -> Result<(), Box<dyn Error>> {
        let codeownership_file = indoc! {"
            # First Section
            /path/to/owned @Foo
            /path/to/not/owned @Bar

            # Last Section
            /another/owned/path @Foo
        "};

        let team_ownership = parse_for_team("@Foo".to_string(), codeownership_file)?;
        vecs_match(
            &team_ownership,
            &vec![
                TeamOwnership {
                    heading: "# First Section".to_string(),
                    globs: vec!["/path/to/owned".to_string()],
                },
                TeamOwnership {
                    heading: "# Last Section".to_string(),
                    globs: vec!["/another/owned/path".to_string()],
                },
            ],
        );
        Ok(())
    }

    #[test]
    fn test_parse_for_team_with_partial_team_match() -> Result<(), Box<dyn Error>> {
        let codeownership_file = indoc! {"
            # First Section
            /path/to/owned @Foo
            /path/to/not/owned @FooBar
        "};

        let team_ownership = parse_for_team("@Foo".to_string(), codeownership_file)?;
        vecs_match(
            &team_ownership,
            &vec![TeamOwnership {
                heading: "# First Section".to_string(),
                globs: vec!["/path/to/owned".to_string()],
            }],
        );
        Ok(())
    }

    #[test]
    fn test_parse_for_team_with_trailing_newlines() -> Result<(), Box<dyn Error>> {
        let codeownership_file = indoc! {"
            # First Section
            /path/to/owned @Foo

            # Last Section
            /another/owned/path @Foo



        "};

        let team_ownership = parse_for_team("@Foo".to_string(), codeownership_file)?;
        vecs_match(
            &team_ownership,
            &vec![
                TeamOwnership {
                    heading: "# First Section".to_string(),
                    globs: vec!["/path/to/owned".to_string()],
                },
                TeamOwnership {
                    heading: "# Last Section".to_string(),
                    globs: vec!["/another/owned/path".to_string()],
                },
            ],
        );
        Ok(())
    }

    #[test]
    fn test_parse_for_team_without_trailing_newline() -> Result<(), Box<dyn Error>> {
        let codeownership_file = indoc! {"
            # First Section
            /path/to/owned @Foo"};

        let team_ownership = parse_for_team("@Foo".to_string(), codeownership_file)?;
        vecs_match(
            &team_ownership,
            &vec![TeamOwnership {
                heading: "# First Section".to_string(),
                globs: vec!["/path/to/owned".to_string()],
            }],
        );
        Ok(())
    }

    #[test]
    fn test_parse_for_team_with_missing_section_header() -> Result<(), Box<dyn Error>> {
        let codeownership_file = indoc! {"
            # First Section
            /path/to/owned @Foo

            /another/owned/path @Foo
        "};

        let team_ownership = parse_for_team("@Foo".to_string(), codeownership_file);
        assert!(
            team_ownership
                .is_err_and(|e| e.to_string() == "CODEOWNERS out of date. Run `codeowners generate` to update the CODEOWNERS file")
        );
        Ok(())
    }

    #[test]
    fn test_parse_for_team_with_malformed_team_line() -> Result<(), Box<dyn Error>> {
        let codeownership_file = indoc! {"
            # First Section
            @Foo
        "};

        let team_ownership = parse_for_team("@Foo".to_string(), codeownership_file);
        assert!(
            team_ownership
                .is_err_and(|e| e.to_string() == "CODEOWNERS out of date. Run `codeowners generate` to update the CODEOWNERS file")
        );
        Ok(())
    }

    #[test]
    fn test_parse_for_team_with_invalid_file() -> Result<(), Box<dyn Error>> {
        let codeownership_file = indoc! {"
            # First Section
            # Second Section
            path/to/owned @Foo
        "};
        let team_ownership = parse_for_team("@Foo".to_string(), codeownership_file)?;
        vecs_match(
            &team_ownership,
            &vec![
                TeamOwnership {
                    heading: "# First Section".to_string(),
                    globs: vec![],
                },
                TeamOwnership {
                    heading: "# Second Section".to_string(),
                    globs: vec!["path/to/owned".to_string()],
                },
            ],
        );
        Ok(())
    }

    #[test]
    fn test_stripped_lines_by_priority() -> Result<(), Box<dyn Error>> {
        let codeownership_file = indoc! {"
            # First Section
            /path/to/owned @Foo
        "};

        let stripped_lines = stripped_lines_by_priority(codeownership_file);
        assert_eq!(stripped_lines, vec!["/path/to/owned @Foo"]);
        Ok(())
    }

    #[test]
    fn test_stripped_lines_by_priority_with_multiple_sections() -> Result<(), Box<dyn Error>> {
        let codeownership_file = indoc! {"
            # First Section
            /path/to/owned @Foo

            # Second Section
            /another/path/to/owned @Bar
        "};

        let stripped_lines = stripped_lines_by_priority(codeownership_file);
        assert_eq!(stripped_lines, vec!["/another/path/to/owned @Bar", "/path/to/owned @Foo"]);
        Ok(())
    }
}
